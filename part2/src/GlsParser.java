import exceptions.GenericSyntaxException;
import exceptions.MissingProductionRuleException;
import exceptions.ParsingException;
import exceptions.UnexpectedTerminalException;

import java.io.IOException;
import java.util.Stack;

/**
 * The GlsParser class is responsible for parsing the input tokens using the GLS grammar.
 */
public class GlsParser {
	private final LexicalAnalyzer lexer;
	private final GlsGrammar grammar;
	private ParseTree parseTree = null;
	private String leftmostDerivation = "";

	/**
	 * Constructs a GlsParser with the specified lexical analyzer and grammar.
	 *
	 * @param lexer   the lexical analyzer
	 * @param grammar the GLS grammar
	 */
	public GlsParser(LexicalAnalyzer lexer, GlsGrammar grammar) {
		this.lexer = lexer;
		this.grammar = grammar;
	}

	/**
	 * Returns the parse tree generated by the parser.
	 *
	 * @return the parse tree
	 */
	public ParseTree getParseTree() {
		return this.parseTree;
	}

	/**
	 * Returns the leftmost derivation of the input.
	 *
	 * @return the leftmost derivation
	 */
	public String getLeftmostDerivation() {
		return this.leftmostDerivation;
	}

	/**
	 * Parses the input tokens and generates the parse tree and leftmost derivation.
	 *
	 * @throws ParsingException if an error occurs
	 * @throws IOException      if an I/O error occurs
	 */
	public void parse() throws ParsingException, IOException {
		Stack<Symbol> stack = new Stack<>(); // Stack to keep track of the grammar symbols
		stack.push(grammar.getStartSymbol()); // Push the start symbol to the stack

		Stack<ParseTree> treeStack = new Stack<>(); // Stack to keep track of parse tree nodes
		this.parseTree = new ParseTree(grammar.getStartSymbol()); // Create the root of the parse tree
		treeStack.push(this.parseTree); // Push the root to the stack

		LexicalSymbol lexicalSymbol = lexer.nextToken();
		GlsTerminal terminal = lexicalSymbol.getType().toGlsTerminal();

		while (!stack.isEmpty()) {
			Symbol x = stack.peek();
			ParseTree currentNode = treeStack.peek();
			GlsVariable v = x instanceof GlsVariable ? (GlsVariable) x : null;

			if (x == GlsTerminal.EPSILON) {
				stack.pop();
				treeStack.pop();
				continue;
			}

			if (v != null && grammar.getProduction(v, terminal) != null) {
				ProductionRule productionRule = grammar.getProduction(v, terminal);
				stack.pop();
				treeStack.pop();
				for (int i = productionRule.getProduction().size() - 1; i >= 0; i--) {
					stack.push(productionRule.getProduction().get(i));
					ParseTree child = new ParseTree(productionRule.getProduction().get(i));
					currentNode.addChild(child);
					treeStack.push(child);
				}
				currentNode.reverseChildrenOrder();
				this.leftmostDerivation += productionRule.getId() + " ";

			} else if (v == null && x == terminal) {
				stack.pop(); // Pop the terminal from the stack
				treeStack.pop(); // Pop the terminal from the tree stack
				lexicalSymbol = lexer.nextToken(); // Get the next token
				terminal = lexicalSymbol.getType().toGlsTerminal(); // Get the LexicalUnit of the next token
			} else {
				if (v == null) {
					throw new UnexpectedTerminalException(
							"Expected terminal " + x + " but found " + terminal
					);
				} else if (grammar.getProduction(v, terminal) == null) {
					throw new MissingProductionRuleException(
							"No production rule for variable " + v + " with terminal " + terminal
					);
				} else {
					throw new GenericSyntaxException(
							"Syntax error at " + terminal + " while parsing " + v
					);
				}
			}
		}
	}
}